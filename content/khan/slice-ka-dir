#!/usr/bin/python
# Scan KA Lite content, update video sizes in blank field in database

import sys, shutil, os.path, argparse, sqlite3

src_dir = "/library/ka-lite/content"
dest_dir = "/library/ka-lite/content"
kalite_dbase_dir = "/library/ka-lite/database"

parser = argparse.ArgumentParser(description="Summarize or Slice Kalite Videos in a directory. List topics, and sizes for top part of Khan topic tree, or paths listed in \"path.list\" file. (or copy them)")
parser.add_argument("-s", "--src", metavar="SRC_DIR", help="get video availability, and sizes from this directory -(default: current working directory")
parser.add_argument("-d","--dest", metavar="DEST_DIR", nargs="?", help="copy videos --requires -p, overrides -v -(default: " + dest_dir + ")")
parser.add_argument("-p","--path_list", metavar="FILENAME", help="the full, or relative, path to the text file containing list of paths. Required to output youtube ID list, or copy videos -(default: whole topic tree starting with \"khan/\"")
parser.add_argument("-v", "--video", help="Instead, output video id list (repuires -p)",action="store_true")
parser.add_argument("-w", "--work", metavar="WORK_DIR", help="copy the KA database here, and update private copy with current video sizes  -(default: SRC_DIR)")
parser.add_argument("-l", "--lang", type=str, default='en', required=False, help="language to select -(default: en)")
parser.add_argument("-f", "--force", help="If -d, copy even if target exists. If not -d (not a copy), force regeneration of local database and file sizes.", action="store_true")

args = parser.parse_args()
lang = args.lang.lower()

kalite_dbase_dir = "/library/ka-lite/database/"
sqlite_file = kalite_dbase_dir + "/content_khan_" + lang + ".sqlite"
if not os.path.isfile(sqlite_file):
    print "Database " + sqlite_file + " not found. Has ka-lite been installed on this machine?"
    print "  Expecting to find khan database at /library/ka-lite/database/."
    sys.exit(1)

if args.src:
   kalite_content_dir = args.src+'/'
else:
   kalite_content_dir = os.getcwd() + '/'
if not os.path.exists(kalite_content_dir):
   print("Directory %s not found. Expecting a directeory containing downloaded Videos."%kalite_content_dir)
   sys.exit(1)
# move the videos that are not in database out of downloaded directory
os.system("mkdir -p %sunused"%kalite_content_dir)
rename_dir = os.path.join(kalite_content_dir,"unused/")

if args.dest and args.dest != '':
   kalite_dest_dir = args.dest

if args.work:
   work_dir = args.work
else:
   work_dir = kalite_content_dir
if not os.path.exists(work_dir):
   print("Directory %s not found. Expecting a directeory to hold working copy of KA database."%work_dir)
   sys.exit(1)


if args.path_list:
   list_file = args.path_list
   if not os.path.isfile(list_file):
      if list_file == '':
         list_file = 'path.list'
      work_spec = os.path.isfile(os.path.join(work_dir,list_file))
      if os.path.isfile(work_spec):
         list_file = work_spec
      else:
         print("Did not fint %s in local, or work directories"%list_file)
         sys.exit(1)
else:
   list_file = ""
if (args.video or args.dest) and list_file == '':
   print("Copying videos, or making a list, requires specifying the subset with a -p option")
   sys.exit(1)

############ a few useful function definitions ################
def human_fmt(num):
    if num == None:
        return ""
    for unit in ['','K','M','G','T','P','E','Z']:
        if abs(num) < 1024.0:
            return "%4.2f%s" % (num, unit,)
        num /= 1024.0
    return "%.1f%s%s" % (num, 'Yi', suffix)

def size_block(fname):
   lSize=os.stat(fname).st_size
   bSize=os.statvfs(fname).f_bsize
   return (lSize/bSize+1)*bSize

def print_subtree(parent):
   global c,videos_total_size,videos_disk_size
   parent_like = parent+'%'
   sql = 'select item.path,sum(filesize),sum(size_data.size_on_disk) from item inner join size_data on item.youtube_id = size_data.youtube_id where item.path like "%s"'%parent_like
   c.execute(sql)
   result = c.fetchone()
   print('%s %s %s'%(parent,human_fmt(result[1]),human_fmt(result[2]),))
   videos_total_size += result[1]
   videos_disk_size += result[2]
   sql = 'select size_data.rowid from item inner join size_data on item.youtube_id = size_data.youtube_id where item.path like "%s"'%parent_like
   c.execute(sql)
   result = c.fetchall()
   for r in result:
      c.execute('insert or ignore into selected (id) values (?)',(r[0],))

def print_videos(parent):
   global c,conn,videos_total_size
   parent_like = parent+'%'
   sql = 'select size_data.youtube_id,filesize,size_data.size_on_disk,filename,size_data.rowid from item inner join size_data on item.youtube_id = size_data.youtube_id where item.path like "%s"'%parent_like
   c.execute(sql)
   pathnames = c.fetchall()
   for path in pathnames:
      print os.path.basename(path[3]),path[1],path[2]
      videos_total_size += path[1]
      c.execute('insert or ignore into selected (id) values (?)',(path[4],))
   conn.commit()

def copy_file(src, dest, force):
   #print 'copy', src, dest
   if not os.path.isfile(src):
      print("%s not found in copy_subtree"%src)
      return False
   if os.path.isfile(dest):
      if not force:
         return False 
   shutil.copy(src, dest)
   return True

def copy_subtree(parent):
   global c,videos_total_size,videos_disk_size
   parent_like = parent+'%'
   sql = 'select item.path,filename,filesize,size_data.size_on_disk from item inner join size_data on item.youtube_id = size_data.youtube_id where item.path like "%s"'%parent_like
   c.execute(sql)
   result = c.fetchall()
   for r in result:
      copied = copy_file(r[1], kalite_dest_dir, args.force)
      if copied:
         videos_total_size += r[2]
         videos_disk_size += r[3]


##################   Begin processing  ######################
video_files = os.listdir(kalite_content_dir)
videos_total_size=0L
videos_disk_size=0L
copy_total_size=0L

my_sqlite_file = work_dir + "/content_khan_" + lang + ".sqlite"

stopper=0
#####  Only need to scan video directory, and update the database, once
if not os.path.isfile(my_sqlite_file) or (args.force and not args.dest):
#if True:
   # update the stock databse with size of each downloaded/available file
   print("Creating working copy of kalite databse and recording file sizes into it")
   shutil.copy(sqlite_file,my_sqlite_file)
   os.system("sync")
   conn = sqlite3.connect(my_sqlite_file)
   # following line causes return of dictionary
   conn.row_factory = sqlite3.Row
   c = conn.cursor()
   sql = "create table size_data (indx integer primary key, path varchar,filename varchar,filesize int,size_on_disk int,parent_id int,youtube_id varchar,path_overlap int);"
   c.execute(sql)

   size = 0
   success=fail=missing=1
   last_hash=""
   for v in video_files:
      #print v
      stopper += 1
      #if stopper > 5: 
      #   conn.commit()
      #   sys.exit(1)
      hash = v.split('.')[0]
      try:
         filepath = os.path.join(kalite_content_dir, v)
         size = int(os.stat(filepath).st_size)
      except:
         print "os.stat.error",filepath
         continue
      c.execute("insert into size_data (filename,filesize,size_on_disk,youtube_id) values (?,?,?,?)",(filepath,size,size_block(filepath),hash))
      if c.rowcount < 1:
         print("Error: failed to insert size_data")
      if success % 500 ==  0:
         print("success:%s, fail:%s "%(success,fail,))
   conn.commit()

   ##########  add a table to hold the top part of the Khan topic tree (controlled by limit)
   sql = '''create table if not exists tree as with recursive chunk(path,pk) as (select path,parent_id from item where parent_id = 16991 union  select item.path,item.pk from item,chunk where item.parent_id = chunk.pk limit 105) select path from chunk;'''

   c = conn.cursor()
   c.execute(sql)
   conn.commit()

##########   Can now assume that the size_data tables is filled with video file sizes 

conn = sqlite3.connect(my_sqlite_file)
# following line causes return of dictionary
conn.row_factory = sqlite3.Row
c = conn.cursor()
sql = "drop table if exists selected"
c.execute(sql)
sql = "create table selected (id int unique)" 
c.execute(sql)
conn.commit()

if list_file:
   print
   print "# Name of file containing list of Topics(paths):%s"%list_file
   for line in  open(list_file,'r'):
      # use the first string in the line -- our list output format includes size
      # But if is starts with a #, skip it
      if line == "" or list_file[0] == '#':
         continue
      parent = line.split(' ')[0]
      if args.dest:
         print("Copying vides in path: %s"%(parent,))
         copy_subtree(parent)
      elif args.video:
         print_videos(parent)
      else:
         print_subtree(parent)
else:
   print
   print "# Recursive list of topics, 3 levels deep"
   sql = 'select path from tree where path like "khan/%"'
   c.execute(sql)
   pathnames = c.fetchall()
   for path in pathnames:
      parent = path[0]
      print_subtree(parent)

# fetch the size of all files selected, discounting overlap of topic paths
sql = 'select sum(filesize),sum(size_on_disk) from size_data inner join selected on size_data.indx = selected.id'
c.execute(sql)
row = c.fetchone()

print("# Total file size discounting topic overlap:%s, including block size:%s"%(human_fmt(row[0]),human_fmt(row[1],)))
print

conn.commit()
conn.close()
sys.exit(0)
