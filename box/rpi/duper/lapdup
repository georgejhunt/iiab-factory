#!/bin/bash -x
# fast copy (using dd) IIAB to an disk image, or a  second SD card; optionally minify image

# Author: george hunt <georgejhunt.gmail.com> https://github.com/georgejhunt/iiab-factory
copyright 2018 by George Hunt
License: GPL Version 2
# Ideas and structure attribution:   jules randolph <jules.sam.randolph@gmail.com> https://github.com/jsamr/bootiso

# Bring in useful functions
source truncate.sh

#############   Set up variables ############
#  All size variables kept in bytes
export TEXTDOMAIN=piconf
typeset -a devicesList


# i18n stuff
if test "$USE_NLS" = "yes" && type -p gettext > /dev/null; then
  xecho() {
    gettext -s "$*"
  }
else
  xecho() {
    echo "$*"
  }
  gettext() {
    echo -n "$*"
  }
fi
xmsg() {
  msg=$(gettext "$1")
  shift
  printf "$msg" $*
}

#########   User interface command line stuff #########
usage() {
    xecho "IIAB SD Card Duplicator"
    echo "  version $version"
    xecho "usage: $0 [options]
  -d|--dest      Destination USB stick
  -h|--help      what you're reading"
}

while (( $# )) ; do
    case "$1" in
    -h|--help)
         usage; exit 0 ;;
    -d|--dest)
         PARTITION="$2"; shift 2;;
    *) usage ; exit 1 ;;
    esac
done

getDevicesList() {
   declare -a devices 
   # pass the arrays by reerence
   local -n usbList=$1
   local -n devicesList=$2
   mapfile -t devices < <(lsblk -o NAME,TYPE | grep  disk | awk '{print $1}')
   echo ${devices[@]}
   for device in "${devices[@]}" ; do
      if [ "$device" = "sdb" ]; then continue; fi
      if [ "$device" = "zram0" ]; then continue; fi
      isUSB "/dev/$device"
      if [ $? -eq 0 ]; then
         usbList+=("$device")
      fi
      devicesList+=("$device")
   done
}

initialize(){
   prefix=/usr/local
   exec_prefix=${prefix}
   bindir=${exec_prefix}/bin
   sbindir=${exec_prefix}/sbin
   SRC_DEVICE=/dev/mmcblk0
   SRC_PARTITION=/dev/mmcblk0p2
   DUPVERSION=0.1
   USE_NLS=no
   # mount all the partitions so that df can return usage
   for dev in `ls /mnt`; do
     if test "$dev" = "sr0"; then continue; fi
     if ! grep $dev /etc/mtab > /dev/null; then
        mount /dev/$dev /mnt/$dev 2>&1 > /dev/null
     fi
   done
   erase_block=8192   # size in sectors
   export TERM=xterm
}

checkSudo() {
  if ((EUID != 0)); then
    echo "Granting root privileges for $scriptName."
    if [[ -t 1 ]]; then
      sudo "$0" "$@"
    else
      exec 1>output_file
      gksu "$0" "$@"
    fi
    exit
  fi
}

################  Choose Source  ###################
selectSource(){
   echo > /tmp/duper/devices
   df -hT | grep mnt | grep -v -e Disk -e sdb | sort >> /tmp/duper/devices

   cat << EOF > /tmp/duper/src
MENU_TITLE=$(gettext "\"Choose Source -- Probably a mmcblk device of type ext4 \n\n\n \\
device            type        size      used       free     %       mounted to\n \\
=================================================================================\"")
SRC=\$(dialog --title "\$PAGE_TITLE" --ok-label "Select" --default-item "/dev/mmcblk0p2  " \\
 --menu "\$MENU_TITLE" 20 90 5    \\
EOF

   while read line
   do
    awk ' { printf("\"%-16s\"  \"%-5s %10s %10s %10s %6s    %-15s\"  \\\n",$1,$2,$3,$4,$5,$6,$7);}'
   done < /tmp/duper/devices >> /tmp/duper/src
   echo  3\>\&1 1\>\&2 2\>\&3\) >> /tmp/duper/src
   source /tmp/duper/src
   if test $? -ne 0 ; then return 99; fi
   SRC_PARTITION=$(echo $SRC | awk '{print $1}')
   SRC_DEVICE=${SRC_PARTITION:0:(-2)}
   echo $SRC
   SRC_SIZE=$(fdisk -l $SRC_DEVICE | grep Linux | awk '{print $4;}')
   SRC_SIZE=$(expr $SRC_SIZE \* 512)
   CHOSEN_SIZE=$SRC_SIZE
   echo $SRC_SIZE
   return 0
}

####  Get the minimun size that Destination must hold
getSourceMinSize(){
   # but first warn user that getting minimun source size will take a while
   delay=$(gettext "Using e2fsck to check the minimum size of $SRC_PARTITION, This may take some time. . .")
   dialog --infobox "$delay" 7 60

   MIN_SIZE=$( min_device_size "$SRC_PARTITION" )  # keep it all in bytes
   #echo minimum source size is $MIN_SIZE
   MIN_SIZE_TEXT=$(gettext "Data on Source Sd card occupies $(bytesToHuman "$MIN_SIZE")")
   echo $MIN_SIZE
   return 0
}

################  Choose Destination  ###################
selectDestination(){
   # the source should not be listed as a potential destination
   ignore=${SRC:0:9}
   echo > /tmp/duper/devices1
   df -hT | grep mnt | grep -v -e Disk -e sdb -e $ignore| sort >> /tmp/duper/devices1

   cat << EOF > /tmp/duper/dest
      PAGE_TITLE=$(gettext "\"Choose Destination\"")
      MENU_TITLE=$(gettext "\"Choose Destination -- Either hard disk partition of type ntfs, or another SD Card \n \\
      \$MIN_SIZE_TEXT  \n\n\n \\
      device            type        size      used       free     %       mounted to\n \\
   =================================================================================\"")
      DEST=\$(dialog --title "\$PAGE_TITLE" --clear --ok-label "Select" --default-item "/dev/mmcblk0p2  " \\
       --menu "\$MENU_TITLE" 20 90 25    \\
EOF

   while read line
   do
    awk ' { printf("\"%-16s\"  \"%-5s %10s %10s %10s %6s    %-15s\"  \\\n",$1,$2,$3,$4,$5,$6,$7);}'
   done < /tmp/duper/devices1 >> /tmp/duper/dest
   echo  3\>\&1 1\>\&2 2\>\&3\) >> /tmp/duper/dest
   source /tmp/duper/dest
   if test $? -ne 0 ; then return 99; fi
   DEST=$(echo "$DEST" | awk '{print $1;}')    # trim trailing spaces
   # currently, the decision on whether destination is a SD card is based upon "mmcblk"
   DEST_PARTITION=$(echo $DEST | awk '{print $1}')
   DEST_DEVICE=${DEST_PARTITION:0:(-1)}
   DEST_FREE=$(/usr/local/bin/df  | grep $DEST_PARTITION | awk '{print $4}')
   # coreutils tce make the above work - really required for dd progress
#   DEST_FREE=$(/bin/df  | grep $DEST_PARTITION | awk '{print $4}')
   DEST_FREE=$(expr "$DEST_FREE" \* 1024)
   DEST_SIZE=$(fdisk -l $DEST_DEVICE | grep Disk | cut -d" " -f 5)
   echo $DEST_SIZE
   dest_is_file=
   echo $DEST_DEVICE | grep sda > /dev/null
   if [ $? -eq 0 ];then
      dest_is_file=true
   fi
}

isUSB() {
  #typeset deviceName=/sys/block/${1#/dev/}
  udevadm info --query=symlink --name="$1" | grep usb
}

assertDeviceIsUSB() {
   typeset deviceType
   dest_is_usb=
   deviceType=$(getDeviceType "$selectedDevice")
   if [ "$deviceType" != "usb" ]  ; then
      msg=$(gettext "The device you selected is not connected through USB (found BUS: \`$deviceType'.\
      Exiting ...")
      title="FATAL ERROR"
      dialog --title "$title" --yesno "$msg" 6 80
      return 99 
   fi
   dest_is_usb=true
}

selectTruncate(){
   # if the destination is much larger than source, let user select the smaller size
   SIZE_DIFF=$(expr $DEST_SIZE - $SRC_SIZE)
   # echo size_diff $SIZE_DIFF

   QUESTION=$(gettext "Do you want to shrink the Source, even if it will fit without this step?")
   QUERY=$(gettext "Minimize Source?")
   dialog --title "$QUERY" --yesno "$QUESTION" 6 80
   if test $? -eq 0; then
      CHOSEN_SIZE=$MIN_SIZE
   else
      CHOSEN_SIZE=$SRC_SIZE
   fi
   return 0
}

dummy(){
#   reminder expr returns 1 if true
   if [ $(expr $SIZE_DIFF \> 8000000000) -eq 1 ]; then
      MENU_TITLE=$(gettext "Data on Source Sd card occupies $(bytesToHuman "$MIN_SIZE")")
      FUN=$(dialog --title "Choose the size of the output SD card" --backtitle "Choose SD size" \
      --menu "Choose SD Size" 17 80 5  --cancel-button Finish --ok-button Select \
        "1 128 GB SD card" "Will verify that space exists" \
        "2 64 GB SD card" "" \
        "3 32 GB SD card" "" \
        "4 16 GB SD card" "" \
        "5 Smallest possible" "Written to available SD" \
        3>&1 1>&2 2>&3)

      RET=$?
      if [ $RET -eq 0 ]; then
        case "$FUN" in
          1\ *) CHOSEN_SIZE=$sd128GB ;;
          2\ *) CHOSEN_SIZE=$sd64GB ;;
          3\ *) CHOSEN_SIZE=$sd32GB ;;
          4\ *) CHOSEN_SIZE=$sd16GB ;;
          5\ *) CHOSEN_SIZE=$MIN_SIZE ;;
        esac
      fi
      # Can't choose a size where the data will not fit
      if [ $(expr $CHOSEN_SIZE \< $MIN_SIZE) -eq 1 ]; then
         CHOSEN_SIZE=$MIN_SIZE
      fi
   fi
   return 0
}
################### Identify the copy  #####################

# Fetch username and appropriate label
createFilename(){
   # generate mount specifiers
   SRC_PARTITION_NIBBLE=${SRC_PARTITION:5}
   SRC_MNT=/mnt/$SRC_PARTITION_NIBBLE
   DEST_PARTITION_NIBBLE=${DEST:5}
   DEST_MNT=/mnt/$DEST_PARTITION_NIBBLE
   name=
   if [ -f /opt/name ]; then
      name=$(cat /opt/name)
   fi
   label=
   if [ -f /opt/label ]; then
      label=$(cat /opt/label)
   fi
   TITLE=$(gettext "Please identify this copy")
   MSG=$(gettext "Requires name and short identifying label")
   exec 3>&1
   DATA=$(dialog --output-separator ":" --title "$TITLE" --form "$MSG" 10 80 3 \
         "Name:" 1 1 "$name" 1 7 15 0 \
         "Label:" 2  1 "$label" 2 7 16 0 \
         2>&1 1>&3)
   if test $? -ne 0 ; then return 99; fi
   NAME=$(echo $DATA | awk -F: '{print $1;}')
   LABEL=$(echo $DATA | awk -F: '{print $2;}')
   # replace spaces with underscores
   NAME=$(echo $NAME | sed 's/ /_/g')
   LABEL=$(echo $LABEL | sed 's/ /_/g')
   echo $LABEL > /opt/label
   echo $NAME > /opt/name
   iiab_label $SRC_PARTITION $NAME $LABEL
   TARGET=$DEST_MNT/$(cat /tmp/duper/identifier_filename)
   echo $TARGET > /opt/lapdup_filename
   return 0
}

# check source and destination exist
existCheck(){
   if [ "$dest_is_usb" = "true" ]; then
     write_to="$DEST_DEVICE"
   else
     write_to="$DEST_PARTITION"
   fi
   if [ ! -e "$write_to" ] || [ ! -e "$SRC_DEVICE" ]; then  
       title=$(gettext "Result")
       msg=$(gettext "Source $SRC_DEVICE or Destination $write_to not found")
       dialog --title "$title"  --msgbox "$msg" 20 60
       return 99 
   fi
   return 0
}

# check source is not open for running linux OS
verifySourceNotBoot(){
   BOOT_DEV=$(mount | grep -e boot -e rootfs | cut -d' ' -f1)
   BOOT_DEV=${BOOT_DEV:0: (-1)}
   #echo boot_dev=$BOOT_DEV
   if [ "$BOOT_DEV" = "$SRC" ]; then
       title=$(gettext "Error")
       msg=$(gettext "Source cannot be the BOOT disk .. quitting")
       echo $msg
       dialog --title "$title"  --msgbox "$msg" 10 60 
       return 99 
   fi
   return 0
}

# Check that a dd copy of source will fit on destination
willItFit(){
   if [ "$dest_is_file" != "true" ]; then
      output_size="$DEST_SIZE"
   else
      output_size="$DEST_FREE"
   fi
   if [ $(expr "$CHOSEN_SIZE" \> "$output_size") -eq 1 ] ; then
     msg=$(gettext "The source $SRC_PARTITION ($CHOSEN_SIZE) will not fit on the destination $DEST_PARTITION" ($output_size))
     title=$(gettext "Fatal ERROR . . . Quitting")
     dialog --title "$title"  --msgbox "$msg" 10 70 
     return 99 
   fi
   return 0
}
save (){
   if [ $(expr "$CHOSEN_SIZE" \< "$output_size") -eq 1 ] ; then
     echo Chosen size:$CHOSEN_SIZE   output size:$output_size
     msg=$(gettext "Truncation of Source is required. \n \
      Source bytes: $CHOSEN_SIZE.   Destination bytes: $(bytesToHuman output_size) \n \
      OK to proceed?")
     human=$(bytesToHuman $CHOSEN_SIZE)
     title=$(gettext "Proceed with resizing Source to $human? \
     Both Source and Destination will be set to expand upon reboot")
     dialog --title "$title"  --yesno "$msg" 10 70 
     if test $? -ne 0 ; then return 99; fi
   fi
}
#####################  Confirm Choices     ###########################
optionalTruncation(){
   if [ "$SRC_SIZE" = "$CHOSEN_SIZE" ]; then
      SOURCE_TRUNCATE=NO
   else
      SOURCE_TRUNCATE=YES
   fi

   if [ "$dest_is_usb" = "true" ]; then
      DEST_INFO=$(gettext "Destination device: $DEST_DEVICE")
   else
      DEST_INFO=$(gettext "Destination filename: $TARGET")
   fi

   SRC_INFO=$(gettext "Source device: $SRC_DEVICE \
   Source will be truncated before copy: $SOURCE_TRUNCATE" )
   TITLE=$(gettext "Please Confirm the following COPY operation" )
   MSG="$SOURCE_INFO\n$DEST_INFO"
   dialog --Title "$TITLE" --yesno "$MSG" 7 70
   if test $? -ne 0; then return 99; fi
   return 0
}
#####################  Final Sanity Check  ###########################
finalVerification(){
   if [ "$dest_is_file" != "true" ]; then
      write_to="$DEST_DEVICE"
      output_size="$DEST_SIZE"
   else
      write_to="$TARGET"
      output_size="$DEST_FREE"
   fi
  output_size=$(bytesToHuman $output_size)
  title=$(gettext "Final Verification")
  msg=$(gettext "\n\nSource: $SRC_DEVICE  Bytes to copy: $(bytesToHuman $CHOSEN_SIZE) \
  \nDestination: $write_to   \n\nSpace on Destination: $output_size")
  dialog --title "$title" --yesno "$msg" 20 80
  if test $? -ne 0 ; then return 99; fi
}

####################### copy the data #################################
ddCopy(){
   if [ "$dest_is_file" != "true" ]; then
      write_to="$DEST_DEVICE"
   else
      write_to="$TARGET"
   fi
   # figure out how many erase_blocks to write
   WRITE_COUNT=$( echo "( $CHOSEN_SIZE / 4096 ) + 1" | bc )

   # at boot, the read-only driver loads
   umount $DEST_PARTITION
   mount -t ntfs-3g "$DEST_PARTITION" "$DEST_MNT"
   if [ ! -e fifo ]; then
      mkfifo fifo
   fi
   dd status=progress if="$SRC_DEVICE" of="$write_to" bs=4096 count=$WRITE_COUNT 2>fifo &

   # now read the fifo and update the gauge
   lastcopied=
   set +x
   while true; do
      sleep 5
      line=$(cat fifo)
      copied=$(echo $line | awk '{print $1}')
      if [ "$copied" = "$lastcopied" ]; then break; fi
      lastcopied=$copied
      percent=$(expr $copied \* 100 / $CHOSEN_SIZE) 
      echo XXX
      echo $percent
      echo $line
      echo XXX 
   done | dialog --title "Image writing" --gauge "Burning the image on the SD card..." 10 78 0
}

ls_menu(){
   # receives path as $1 and a location to write file at $2
   declare -a lookup
   mkdir -p $(dirname $2)
   list=$(ls -l $1 | awk '{print $9}')
   index=1
   for f in $list;do
     size=$( ls -lh $1/$f | awk '{print $5}') 
     (printf '\"%-2s\"  \"%-9s %-20s\" \\\n' $index $size $f) >> $2 
     lookup[$index]=$f
     index=$(( $index + 1 ))
   done
   echo ${lookup[@]}
}

get_nth(){
   index=1
   nth=$1
   shift
   choice_list=$@
   for ch in $choice_list; do
      if [ "$index" = "$nth" ]; then break; fi 
      index=$(( index + 1 ))
   done
   echo $ch
}

selectImage(){
   local TMP_FILE=$1
   local PARTITION=$2
   cat << EOF > "$TMP_FILE"
   CHOICE=\$(dialog --title "\$PAGE_TITLE" --clear --ok-label "Select"  \\
    --menu "\$MENU_MSG" 20 90 25    \\
EOF
   image_list=$(ls_menu $PARTITION $TMP_FILE)
   echo  3\>\&1 1\>\&2 2\>\&3\) >> $TMP_FILE

   source "$TMP_FILE"
   if test $? -ne 0; then return 99; fi

   # trim the string
   CHOICE=$(echo $CHOICE | awk '{print $1}')
   echo /mnt/sda1/$(get_nth $CHOICE $image_list )
}

selectFile(){
   TMP_FILE=/tmp/duper/copy2sd
   PART=/mnt/sda1
   cat << EOF > "$TMP_FILE"
   TITLE=$(gettext "Select Source Image")
   MSG=$(gettext "Choose hard disk image to Copy to SD card")
EOF
   image_path=$(selectImage  $TMP_FILE $PART)
   if test $? -ne 0; then return 99; fi
}

################   Top Level Action Routines   ####################
copySD(){
   selectSource
   verifySourceNotBoot
   selectDestination
   if [  "$dest_is_file" = "true" ]; then
      createFilename
   else
      assertDeviceIsUSB
   fi
   willItFit
   finalVerification
   ddCopy
}

makeSmaller(){
   TMP_FILE=/tmp/duper/smaller
   PART=/mnt/sda1
   cat << EOF > "$TMP_FILE"
   TITLE=$(gettext "\"Choose Image to make Smaller\"")
   MSG=$(gettext "\"Must have unused space to be of much use\"")
EOF
   image_path=$(selectImage  $TMP_FILE $PART)

   # get the proposed new size
   new_size=$(min_device_size $image_path)
   human=$(bytesToHuman $new_size)
   current_size=$(ls -lh $image_path | awk '{print $5}')
   
   TITLE=$(gettext "OK to proceed?")
   MSG=$(gettext "The image file $image_path is currently $current_size. \n
It's new size will be $human. Do you want to proceed?")
   
   dialog --title "$TITLE" --yesno "$MSG" 6 80
   if test $? -ne 0; then return 99; fi

   size_image $image_path
   return 99 
}

image2SD(){
   selectFile
   selectTarget
   willItFit
   doDdCopy
}

deleteImage(){
   TMP_FILE=/tmp/duper/delete
   PART=/mnt/sda1
   cat << EOF > $TMP_FILE
   TITLE=$(gettext "\"Choose a File to Delete\"")
   MSG=$(gettext "\"Highlight the file you wish to delete\"")
EOF
   image_path=$(selectImage  $TMP_FILE $PART)
   if test $? -ne 0; then return 99; fi

   TITLE=$(gettext "OK to proceed?")
   MSG=$(gettext "The image file $image_path is about to be deleted. \
Do you want to proceed?")
   
   dialog --title "$TITLE" --yesno "$MSG" 6 80
   if test $? -ne 0; then return 99; fi

   rm -f $image_path
   return 99 
}

#######################   Main Menu   ###############################
mainMenu(){
   choice1=$(gettext "Copy to SD Card or hard disk")
   choice2=$(gettext "Reduce the size of hard disk image")
   choice3=$(gettext "Copy from hard disk image to SD card")
   choice4=$(gettext "Delete hard disk image")
   choice5=$(gettext "Help")
   choice6=$(gettext "Exit to command line terminal")
   title=$(gettext "Main Menu")
   msg=$(gettext "\n\nPlease choose from the following options:")
   ACTION=$(dialog --title "$title"  --ok-button Select --cancel-button quit --menu "$msg" 17 80 7   \
   "copysd" "$choice1" \
   "smaller" "$choice2" \
   "image2sd" "$choice3" \
   "delete" "$choice4" \
   "help" "$choice5" \
   "terminal" "$choice6" \
   3>&1 1>&2 2>&3)
   if test $? -ne 0 ; then exit 1 ; fi
   case "$ACTION" in
      copysd) copySD
         ;;
      smaller) makeSmaller
         ;;
      image2sd) image2SD
         ;;
      delete) deleteImage
         ;;
      help|*)
         usage
         ;;
      terminal)
         clear
         exit 0
         ;;
   esac
}

cleanup(){
   if [ $? -eq 99 ]; then
      main
   fi
   echo devicesList: ${devicesList[*]}
   echo "usbList: ${usbList[@]}"
   umount /mnt/$SRC_DEVICE
   if [ "$dest_is_usb" = "true" ]; then
      umount "$DEST_DEVICE"
   fi
}

main(){
   while true; do
      mainMenu
   done
}

trap cleanup EXIT INT TERM

initialize "$@"
checkSudo "$@"

main "$@"
