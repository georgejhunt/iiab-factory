#!/usr/bin/python
# Scan KA Lite content, update video sizes in blank field in database

import sys, shutil, os.path, argparse, sqlite3

src_dir = "/library/ka-lite/content"
dest_dir = "/library/ka-lite/content"
kalite_dbase_dir = "/library/ka-lite/database"

parser = argparse.ArgumentParser(description="Summarize or Slice Kalite Videos in a directory. List topics, and sizes for top part of Khan topic tree, or paths listed in \"path.list\" file. (or copy them)")
parser.add_argument("-s", "--src", metavar="SRC_DIR", help="get video availability, and sizes from this directory -(default: current working directory")
parser.add_argument("-d","--dest", metavar="DEST_DIR", nargs="?", help="copy videos --requires -p, overrides -v -(default: " + dest_dir + ")")
parser.add_argument("-p","--path_list", metavar="FILENAME", help="the full, or relative, path to the text file containing list of paths. Required to output youtube ID list, or copy videos -(default: whole topic tree starting with \"khan/\"")
parser.add_argument("-v", "--video", help="Instead, output video id list (repuires -p)",action="store_true")
parser.add_argument("-w", "--work", metavar="WORK_DIR", help="copy the KA database here, and update private copy with current video sizes  -(default: SRC_DIR)")
parser.add_argument("-l", "--lang", type=str, default='en', required=False, help="language to select -(default: en)")
parser.add_argument("-f", "--force", help="If -d, copy even if target exists. If not -d (not a copy), force regeneration of local database and file sizes.", action="store_true")

args = parser.parse_args()
lang = args.lang.lower()

kalite_dbase_dir = "/library/ka-lite/database/"
sqlite_file = kalite_dbase_dir + "/content_khan_" + lang + ".sqlite"
if not os.path.isfile(sqlite_file):
    print "Database " + sqlite_file + " not found. Has ka-lite been installed on this machine?"
    print "  Expecting to find khan database at /library/ka-lite/database/."
    sys.exit(1)

if args.src:
   kalite_content_dir = args.src+'/'
else:
   kalite_content_dir = os.getcwd() + '/'
if not os.path.exists(kalite_content_dir):
   print("Directory %s not found. Expecting a directeory containing downloaded Videos."%kalite_content_dir)
   sys.exit(1)
# move the videos that are not in database out of downloaded directory
os.system("mkdir -p %sunused"%kalite_content_dir)
rename_dir = os.path.join(kalite_content_dir,"unused/")

if args.dest and args.dest != '':
   kalite_dest_dir = args.dest

if args.work:
   work_dir = args.work
else:
   work_dir = kalite_content_dir
if not os.path.exists(work_dir):
   print("Directory %s not found. Expecting a directeory to hold working copy of KA database."%work_dir)
   sys.exit(1)


if args.path_list:
   list_file = args.path_list
   if not os.path.isfile(list_file):
      if list_file == '':
         list_file = 'path.list'
      work_spec = os.path.isfile(os.path.join(work_dir,list_file))
      if os.path.isfile(work_spec):
         list_file = work_spec
      else:
         print("Did not fint %s in local, or work directories"%list_file)
         sys.exit(1)
else:
   list_file = ""
if (args.video or args.dest) and list_file == '':
   print("Copying videos, or making a list, requires specifying the subset with a -p option")
   sys.exit(1)

############ a few useful function definitions ################
def human_fmt(num):
    for unit in ['','K','M','G','T','P','E','Z']:
        if abs(num) < 1024.0:
            return "%4.2f%s" % (num, unit,)
        num /= 1024.0
    return "%.1f%s%s" % (num, 'Yi', suffix)

def size_block(fname):
   lSize=os.stat(fname).st_size
   bSize=os.statvfs(fname).f_bsize
   return (lSize/bSize+1)*bSize

def print_subtree(parent):
   global c,videos_total_size,videos_disk_size
   parent_like = parent+'%'
   sql = 'drop table if exists with_duplicates'
   c.execute(sql)
   # select all in this path, insert into unique hash list eliminating duplicates
   sql = 'create table with_duplicates as select youtube_id,filename, filesize, size_on_disk from size_data where path like "%s"'%parent_like
   c.execute(sql)
   # add these files the the selected aggregation
   c.execute("select * from with_duplicates")
   rows = c.fetchall()
   for row in rows:
      sql = 'insert or ignore into selected (youtube_id,filename,filesize,size_on_disk) values (?,?,?,?)'
      c.execute(sql,(row["youtube_id"],row["filename"],row["filesize"],row["size_on_disk"],))
#   print(row["youtube_id"],row["filename"],row["filesize"],row["size_on_disk"],)
   # delete duplicates
   sql = 'delete from with_duplicates where rowid not in (select  min(rowid) from with_duplicates group by filename)'
   c.execute(sql)
   sql = 'drop table if exists no_duplicates'
   c.execute(sql)
   sql = 'alter table with_duplicates rename to no_duplicates'
   c.execute(sql)
   sql = 'select sum(filesize), sum(size_on_disk) from no_duplicates group by youtube_id'
   c.execute(sql)
   sql = 'drop table if exists summary'
   c.execute(sql)
   sql = 'create table summary as select sum(filesize), sum(size_on_disk) from no_duplicates'
   c.execute(sql)
   c.execute('select * from summary')
   result = c.fetchone()
   conn.commit()
   print('%s %s %s'%(parent,human_fmt(result[0]),human_fmt(result[1]),))

def print_videos(parent):
   global c,videos_total_size
   parent = parent+'%'
   sql = "drop table if exists videos"
   c.execute(sql)
   sql = 'create table videos as select youtube_id,size_on_disk from item where path like "%s"'%parent
   c.execute(sql)
   sql = "select max(youtube_id),max(size_on_disk) from videos group by youtube_id"
   c.execute(sql)
   pathnames = c.fetchall()
   for path in pathnames:
      if path[0] != None:
         print path[0],path[1]
         videos_total_size += path[1]

def copy_file(src, dest, force):
   #print 'copy', src, dest
   if not os.path.isfile(src):
      print("%s not found in copy_subtree"%src)
      return False
   if os.path.isfile(dest):
      if not force:
         return False 
   shutil.copy(src, dest)
   return True

def copy_subtree(parent):
   global c,videos_total_size
   parent = parent+'%'
   sql = "drop table if exists copy"
   c.execute(sql)
   sql = 'create table copy as select youtube_id from item where path like "%s"'%parent
   c.execute(sql)
   sql = "select distinct * from copy"
   c.execute(sql)
   ids = c.fetchall()
   for id in ids:
      src = kalite_content_dir + id[0] + ".mp4"
      if not os.path.isfile(src):
         print("lost:%s "%src)
         continue
      dest = kalite_dest_dir + id[0] + ".mp4"
      copied = copy_file(src, dest, args.force)
      if not copied:
         continue
      src = kalite_content_dir + id[0] + ".png"
      dest = kalite_dest_dir+ id[0] + ".png"
      copied = copy_file(src, dest, args.force)


##################   Begin processing  ######################
video_files = os.listdir(kalite_content_dir)
videos_total_size=0L
videos_disk_size=0L
copy_total_size=0L

my_sqlite_file = work_dir + "/content_khan_" + lang + ".sqlite"

stopper=0
#####  Only need to scan video directory, and update the database, once
if not os.path.isfile(my_sqlite_file) or (args.force and not args.dest):
#if True:
   # update the stock databse with size of each downloaded/available file
   print("Creating working copy of kalite databse and recording file sizes into it")
   shutil.copy(sqlite_file,my_sqlite_file)
   os.system("sync")
   conn = sqlite3.connect(my_sqlite_file)
   # following line causes return of dictionary
   conn.row_factory = sqlite3.Row
   c = conn.cursor()
   sql = "create table size_data ( pk int, path varchar,filename varchar,filesize int,size_on_disk int,parent_id int,youtube_id varchar,path_overlap int);"
   c.execute(sql)

   size = 0
   success=fail=missing=1
   last_hash=""
   for v in video_files:
      #print v
      stopper += 1
      #if stopper > 5: 
      #   conn.commit()
      #   sys.exit(1)
      hash = v.split('.')[0]
      if True:
         try:
            filepath = os.path.join(kalite_content_dir, v)
            size = int(os.stat(filepath).st_size)
         except:
            print "os.stat.error",filepath
            continue
         # find out how many paths are associated with this hash
         sql = 'select count(*) as num,* from item where youtube_id = "%s"'%hash
         #print sql
         c.execute(sql)
         rows = c.fetchall()
         num = rows[0]['num']
         if num > 0:
            sql = 'select * from item where youtube_id = "%s"'%hash
            c.execute(sql)
            rows = c.fetchall()
            success += 1
            for row in rows:
               c.execute("insert into size_data (pk,path,filename,filesize,size_on_disk,parent_id,youtube_id,path_overlap) values (?,?,?,?,?,?,?,?)",(row['pk'],row['path'],filepath,size,size_block(filepath),row['parent_id'],hash,num))
            if c.rowcount < 1:
               print("Error: failed to insert size_data")
         else:
            fail += 1
            print "failed to find ",hash,size,size_block(filepath),v,filepath
      if success % 500 ==  0:
         print("success:%s, fail:%s "%(success,fail,))
   conn.commit()

   ##########  add a table to hold the top part of the Khan topic tree (controlled by limit)
   sql = '''create table if not exists tree as with recursive chunk(path,pk) as (select path,parent_id from item where parent_id = 16991 union  select item.path,item.pk from item,chunk where item.parent_id = chunk.pk limit 105) select path from chunk;'''

   c = conn.cursor()
   c.execute(sql)
   conn.commit()

##########   Can now assume that the size_data tables is filled with video file sizes 

conn = sqlite3.connect(my_sqlite_file)
# following line causes return of dictionary
conn.row_factory = sqlite3.Row
c = conn.cursor()
sql = "drop table if exists selected"
c.execute(sql)
sql = "create table selected (youtube_id varchr unique, filename varchar, filesize int,size_on_disk int)"
c.execute(sql)
conn.commit()

if list_file:
   print
   print "# Name of file containing list of Topics(paths):%s"%list_file
   for line in  open(list_file,'r'):
      # use the first string in the line -- our list output format includes size
      # But if is starts with a #, skip it
      if line == "" or list_file[0] == '#':
         continue
      parent = line.split(' ')[0]
      if args.dest:
         print("Copying selected by %s"%(parent,))
         copy_subtree(parent)
      elif args.video:
         print_videos(parent)
      else:
         print_subtree(parent)
else:
   print
   print "# Recursive list of topics, 3 levels deep"
   sql = 'select path from tree where path like "khan/%"'
   c.execute(sql)
   pathnames = c.fetchall()
   for path in pathnames:
      parent = path[0]
      print_subtree(parent)

# eliminate duplicate file names
sql = 'delete from selected where rowid not in (select  min(rowid) from selected group by filename)'
c.execute(sql)
sql = 'select  sum(filesize),sum(size_on_disk) from selected'
c.execute(sql)
result = c.fetchone()

print("# Total size for files themselves:%s, including block size adder:%s"%(human_fmt(result[0]),human_fmt(result[1]),))
print

conn.commit()
conn.close()
sys.exit(0)
