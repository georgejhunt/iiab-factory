#!/bin/bash -x
# fast copy (using dd) IIAB to an disk image, or a  second SD card; optionally minify image

# Author: george hunt <georgejhunt.gmail.com> https://github.com/georgejhunt/iiab-factory
copyright 2018 by George Hunt
License: GPL Version 2
# Ideas and structure attribution:   jules randolph <jules.sam.randolph@gmail.com> https://github.com/jsamr/bootiso

# Bring in useful functions
source truncate.sh

#############   Set up variables ############
#  All size variables kept in bytes
export TEXTDOMAIN=piconf
declare SRC_DEVICE=/dev/mmcblk0
declare SRC_DEVICE_HOLDS
declare SRC_PARTITION=/dev/mmcblk0p2
declare SRC_PARTITIONED_SIZE       # total bytes specified in partition table
declare SRC_FILE_SIZE
declare DEST_DEVICE=/dev/sda
declare DEST_DEVICE_SIZE
declare DEST_PARTITION=/dev/sda1
declare DEST_PARTITION_SIZE
declare LAPTOP_DEVICE=sda
declare LAPTOP_MOUNT=/mnt/sda1
declare LAPTOP_DIR=/mnt/sda1/iiab
declare TINY_CORE_NIBBLE=sdb       # the Tiny Core Linux boot device
declare BOOT_DEVICE=/dev/sdb       # the Tiny Core Linux boot device
##############   Inputs to shared functions  ##########
declare WILLITFIT_SRC_SIZE
declare WILLITFIT_SRC_SPEC
declare WILLITFIT_DEST_SIZE
declare WILLITFIT_DEST_SPEC
declare DD_SRC
declare DD_DEST
declare PERSIST_STATE_FILE=/opt/duper/state
declare dest_is_file

# Persistence will be maintained for
# User name, label, Laptop partition used by duper,

# i18n stuff
if test "$USE_NLS" = "yes" && type -p gettext > /dev/null; then
  xecho() {
    gettext -s "$*"
  }
else
  xecho() {
    echo "$*"
  }
  gettext() {
     echo -n "$*"
  }
fi
xmsg() {
  msg=$(gettext "$1")
  shift
  printf "$msg" $*
}

#########   User interface command line stuff #########
usage() {
    xecho "IIAB SD Card Duplicator"
    echo "  version $version"
    xecho "usage: $0 [options]
  -d|--dest      Destination USB stick
  -h|--help      what you're reading"
}

while (( $# )) ; do
    case "$1" in
    -h|--help)
         usage; exit 0 ;;
    -d|--dest)
         PARTITION="$2"; shift 2;;
    *) usage ; exit 1 ;;
    esac
done

getDevicesList() {
   declare -a devices 
   # pass the array by reerence
   local -n devicesList=$1
   mapfile -t devices < <(lsblk -o NAME,TYPE | grep  disk | awk '{print $1}')
   echo ${devices[@]}
   for device in "${devices[@]}" ; do
      if [ "$device" = "sdb" ]; then continue; fi
      if [ "$device" = "zram0" ]; then continue; fi
      devicesList+=("$device")
   done
}

initialize(){
   prefix=/usr/local
   exec_prefix=${prefix}
   bindir=${exec_prefix}/bin
   sbindir=${exec_prefix}/sbin
   DUPVERSION=0.1
   USE_NLS=no
   # mount all the partitions so that df can return usage
   for dev in `ls /mnt`; do
     if test "$dev" = "sr0"; then continue; fi
     if ! grep $dev /etc/mtab > /dev/null; then
        mount /dev/$dev /mnt/$dev 2>&1 > /dev/null
     fi
   done
   BOOT_DEVICE=$(grep /home /etc/mtab | awk '{print $1}')
   BOOT_DEVICE=${BOOT_DEVICE:0:8}
   TINY_CORE_NIBBLE=${BOOT_DEVICE:5}
   export TERM=xterm
   mkdir -p /tmp/duper
   mkdir -p /opt/duper
}

checkSudo() {
  if ((EUID != 0)); then
    echo "Granting root privileges for $scriptName."
    if [[ -t 1 ]]; then
      sudo "$0" "$@"
    else
      exec 1>output_file
      gksu "$0" "$@"
    fi
    exit
  fi
}

isUSB() {
  udevadm info --query=symlink --name="$1" | grep usb
}

################  Choose Source  ###################
selectSource(){
   declare -a deviceList
   echo > /tmp/duper/src
   cat << EOF > /tmp/duper/src
TITLE=$(gettext "\"CHOOSE SOURCE SD CARD -- $OBJECTIVE\"")
MSG=$(gettext "\"Choose Source -- Probably a mmcblk device \n\n\n \\
device            type        size      used       free     %       mounted to\n \\
=================================================================================\"")
SRC=\$(dialog --title "\$TITLE" --ok-label "Select" --default-item "mmcblk0    " \\
 --menu "\$MSG" 20 90 5    \\
EOF
   devices=$(getDevicesList $deviceList)
   (for d in $devices; do
      if [ "$d" = "$LAPTOP_DEVICE" ]; then continue; fi
      if [ "$d" = "$TINY_CORE_NIBBLE" ]; then continue; fi
      if [ "$d" = "zram0" ]; then continue; fi
      size=$(fdisk -l /dev/$d | grep Disk | grep /dev/$dd | awk '{print $3}')
      units=$(fdisk -l /dev/$d | grep Disk | grep /dev/$dd | awk '{print $4}')
      echo "$d $size $units" | awk '{printf("\"%-10s \"    \"%-6s %-6s\" \\\n",$1,$2,$3)}'
   done ) >> /tmp/duper/src
   echo  "3>&1 1>&2 2>&3)" >> /tmp/duper/src
   echo "rtn=\$?" >> /tmp/duper/src
   echo "echo \$SRC" >> /tmp/duper/src
   echo "return \$rtn" >> /tmp/duper/src
   SRC=$(source /tmp/duper/src)
   if test $? -ne 0 ; then 
      error_msg=$SRC
      return 99
   fi
   SRC_NIBBLE=$(echo "$SRC" | awk '{print $1}')
   SRC_DEVICE=/dev/$SRC_NIBBLE
   SRC_DEVICE_HOLDS=$(fdisk -l "$SRC_DEVICE" | grep Disk | awk '{print $5;}')
   echo $SRC
   SRC_SIZE=$(fdisk -l "$SRC_DEVICE" | grep Linux | awk '{print $4;}')
   SRC_SIZE=$(expr $SRC_SIZE \* 512)
   CHOSEN_SIZE=$SRC_SIZE
   echo $SRC_SIZE
   return 0
}

################  Choose Destination  ###################
selectSDDestination(){
   echo > /tmp/duper/sddevice
   cat << EOF > /tmp/duper/sddevice
TITLE=\$(gettext "\"Choose SD card as Destination\"")
MSG=\$(gettext "\"If you have not removed the source SD card, and replaced it with a blank SD, \ndo not select mmcblk0.. \n\n\n \\
device            size        mounted to\n \\
=================================================================================\"")
DEST=\$(dialog --title "\$TITLE" --clear --ok-label "Select"  \\
 --menu "\$MSG" 20 90 25    \\
EOF
   (lsblk -o NAME,SIZE,TYPE  | grep disk | grep -v -e sdb -e sda -e zram0 | \
      awk '{ printf("\"%-16s\"  \" %-10s\"  \\\n",$1,$2);}' ) >> /tmp/duper/sddevice
   echo  3\>\&1 1\>\&2 2\>\&3\) >> /tmp/duper/sddevice
   echo "echo \$DEST" >> /tmp/duper/sddevice
   error_msg=$(source /tmp/duper/sddevice)
   if test $? -ne 0 ; then return 99; fi
   DEST_NIBBLE=$(echo "$error_msg" | awk '{print $1}')
   error_msg=
   DEST_DEVICE=/dev/$DEST_NIBBLE
   DEST_SIZE=$(fdisk -l $DEST_DEVICE | grep Disk | cut -d" " -f 5)
   WILLITFIT_DEST_SIZE=$DEST_SIZE
}

selectDevice(){
   declare -a deviceList
   # the source should not be listed as a potential destination
   echo > /tmp/duper/copyto
   cat << EOF > /tmp/duper/copyto
      TITLE=$(gettext "\"CHOSE DEVICE -- $OBJECTIVE\"")
      EXTRA=$(gettext "\"Storage Drive\"")
      MSG=$(gettext "\"Choose Destination -- Either hard disk partition of type ntfs, or another SD Card \n \\
      \$MIN_SIZE_TEXT  \n\n\n \\
                               device      size   \n \\
   =================================================================================\"")
      DEST=\$(dialog --title "\$TITLE" --clear --ok-label "SD Card"  \\
         --extra-button --extra-label "\$EXTRA" --default-button extra \\
         --menu "\$MSG" 20 90 25    \\
EOF

   devices=$(getDevicesList $deviceList)
   (for d in $devices; do
      if [ "$d" = "$SRC_DEVICE" ]; then continue; fi
      if [ "$d" = "$TINY_CORE_NIBBLE" ]; then continue; fi
      if [ "$d" = "zram0" ]; then continue; fi
      if [ "$d" = "$SRC_NIBBLE" ]; then continue; fi
      size=$(fdisk -l /dev/$d | grep Disk | grep /dev/$dd | awk '{print $3}')
      units=$(fdisk -l /dev/$d | grep Disk | grep /dev/$dd | awk '{print $4}')
      echo "$d $size $units" | awk '{printf("\"%-10s \"    \"%-6s %-6s\" \\\n",$1,$2,$3)}'
   done ) >> /tmp/duper/copyto
   echo  "3>&1 1>&2 2>&3)" >> /tmp/duper/copyto
   source /tmp/duper/copyto
   code=$?
   case $code in
      0)
         dest_is_file="false"
         ;;
      3) 
         dest_is_file="true"
         ;;
      *) 
         exit 99
         ;;
   esac
   #if test -ne 0 ; then return 99; fi
   DEST=$(echo "$DEST" | awk '{print $1;}')    # trim trailing spaces
   echo $DEST
}

selectDestination(){
   selectDevice $OBJECTIVE
   DEST_DEVICE=/dev/$DEST
   DEST_SIZE=$(fdisk -l $DEST_DEVICE | grep Disk | cut -d" " -f 5)
   LAPTOP_DEVICE=/dev/$DEST
   echo dest_is_file:$dest_is_file
   if [ "$dest_is_file" = "true" ]; then
      # pick the partition
      selectPartition $DEST_DEVICE $OBJECTIVE
      if test $? -ne 0 ; then return 99; fi
      DEST_PARTITION_MOUNT=/mnt/${PARTITION:5}

      # PREFERRED_MOUNT is remembered for resize, delete, and copy image commands
      PREFERRED_MOUNT=$DEST_PARTITiON_MOUNT
      persistVariable "PREFERRED_MOUNT" $DEST_PARTITION_MOUNT
      if [ $? -ne 0 ]; then return 99; fi
      # trim the response
      DEST_PARTITiON=$(echo $DEST_PARTITION | awk '{print $1}')
      DEST_FREE=$(/usr/local/bin/df -l | grep $DEST_PARTITION | awk '{print $4}')
      # coreutils tce make the above work - really required for dd progress
   #   DEST_FREE=$(/bin/df  | grep $DEST_PARTITION | awk '{print $4}')
      DEST_FREE=$(expr "$DEST_FREE" \* 1024)
   fi
}

################### Identify the copy  #####################

# Fetch username and appropriate label
createFilename(){
   # generate mount specifiers
   SRC_PARTITION_NIBBLE=${SRC_PARTITION:5}
   SRC_MNT=/mnt/$SRC_PARTITION_NIBBLE
   DEST_MNT=$DEST_PARTITION_MOUNT
   name=$(getPersistedVariable NAME)
   label=$(getPersistedVariable LABEL)
   TITLE=$(gettext "Please identify this copy -- $OBJECTIVE")
   MSG=$(gettext "Requires your name and short identifying label")
   exec 3>&1
   DATA=$(dialog --output-separator ":" --title "$TITLE" --form "$MSG" 10 80 3 \
         "Name:" 1 1 "$name" 1 7 15 0 \
         "Label:" 2  1 "$label" 2 7 16 0 \
         2>&1 1>&3)
   if test $? -ne 0 ; then return 99; fi
   NAME=$(echo $DATA | awk -F: '{print $1;}')
   LABEL=$(echo $DATA | awk -F: '{print $2;}')
   # replace spaces with underscores
   NAME=$(echo $NAME | sed 's/ /_/g')
   LABEL=$(echo $LABEL | sed 's/ /_/g')
   persistVariable NAME $NAME
   persistVariable LABEL $LABEL
   local target=$(iiab_label $SRC_MNT $NAME $LABEL)
   TARGET=$DEST_PARTITION_MOUNT/iiab/$target
   return 0
}

# verify that the copy of source will fit on destination
willItFit(){
   if [ $(expr "$WILLITFIT_SRC_SIZE" \> "$WILLITFIT_DEST_SIZE") -eq 1 ] ; then
     MSG=$(gettext "The source $WILLITFIT_SRC_SPEC ($bytesToHuman($WILLITFIT_SRC_SIZE)) \
  will not fit on the destination $WILLITFIT_DEST_SPEC" ($(bytesToHuman($WILLITFIT_DEST_SIZE))))
     TITLE=$(gettext "Fatal ERROR . . . Quitting")
     dialog --title "$TITLE"  --msgbox "$MSG" 10 70 
     return 99 
   fi
   return 0
}

#####################  Final Sanity Check  ###########################
finalVerification(){
   if [ "$dest_is_file" != "true" ]; then
      write_to="$DEST_DEVICE"
      output_size="$DEST_SIZE"
   else
      write_to="$TARGET"
      output_size="$DEST_FREE"
   fi
  output_size=$(bytesToHuman $output_size)
  title=$(gettext "Final Verification")
  msg=$(gettext "\n\nSource: $SRC_DEVICE  \nBytes to copy: $(bytesToHuman $CHOSEN_SIZE) \
  \nSource device capacity: $(bytesToHuman $SRC_DEVICE_HOLDS)
  \n\nDestination: $write_to   \nSpace on Destination: $output_size")
  dialog --title "$title" --yesno "$msg" 20 80
  if test $? -ne 0 ; then return 99; fi
}

####################### copy the data #################################
ddCopy(){
   if [ "$dest_is_file" != "true" ]; then
      write_to="$DEST_DEVICE"
   else
      # writing to our hard disk
      DEST_MNT=$(getPersistedVariable PREFERRED_MOUNT)
      PART=/dev/${DEST_MNT:5}
      # at boot, the read-only driver loads
      umount $DEST_MNT
      mount -t ntfs-3g "$PART" "$DEST_MNT"
      write_to="$TARGET"
      mkdir -p $(dirname $TARGET)
   fi
   # figure out how many 4K blocks to write
   WRITE_COUNT=$( echo "( $CHOSEN_SIZE / 4096 ) + 1" | bc )


   copied=9
   dd status=progress if="$SRC_DEVICE" of="$write_to" bs=4096 count=$WRITE_COUNT 2>&1 | stdbuf -o0 tr "\015" '\n' | \
   while read -r line; do
      copied=$(echo $line | awk '{print $1}')
      if [ -z "$copied" ]; then 
         copied=0; 
         line=""
      fi
      percent=$(expr $copied \* 100 / $CHOSEN_SIZE) &> /dev/null
      echo "copied: $copied  percent: $percent"
      echo XXX
      echo $percent
      echo $line
      echo XXX 
  done | dialog --title "writing to $write_to" --gauge "Copying the image.. This may take some time ... " 10 78 0
  set -x
}

get_nth(){
   index=1
   nth=$1
   shift
   choice_list=$@
   for ch in $choice_list; do
      if [ "$index" = "$nth" ]; then break; fi 
      index=$(( index + 1 ))
   done
   echo $ch
}

selectPartition(){
   local device=$1
   local default=$(persistVariable PREFERRED_MOUNT $device)
   declare -n objective=$2
   if [ ! -z "$default" ]; then
      DEFAULT="--default-item $default"
   else
      DEFAULT=
   fi
   cat << EOF > /tmp/duper/partition
   TITLE=$(gettext "\"Select Partition -- $OBJECTIVE\"")
   MSG=$(gettext "\"Probably should pick the ntfs partition with the most free space\"")
   PARTITION=\$(dialog --title "\$TITLE" --clear --ok-label "Select"  $DEFAULT \\
       --menu "\$MSG" 20 90 25    \\
EOF
   (df -hT | grep $device | \
      awk ' { printf("\"%-16s\"  \"%-5s %10s %10s %10s %6s    %-15s\"  \\\n",$1,$2,$3,$4,$5,$6,$7);}' ) \
      >> /tmp/duper/partition
   echo  "3>&1 1>&2 2>&3)" >> /tmp/duper/partition
   source /tmp/duper/partition
   if test $? -ne 0 ; then return 99; fi
   PARTITION=$(echo $PARTITION | awk '{print $1}')
}

selectImage(){
   # called by selectFile, makeSmaller, deleteImage
   # returns full path selected
   local TMP_FILE=$2
   declare -a lookup
   mkdir -p $(dirname $2)
   cat << EOF > "$TMP_FILE"
   CHOICE=\$(dialog --title "\$TITLE" --clear --ok-label "Select"  \\
    --menu "\$MSG" 20 90 25    \\
EOF
   list=$(ls -l $1 | awk '{print $9}')
   index=1
   for f in $list;do
     size=$( ls -lh $1/$f | awk '{print $5}') 
     (printf '\"%-2s\"  \"%-9s %-20s\" \\\n' $index $size $f) >> $2 
     lookup[$index]=$f
     index=$(( $index + 1 ))
   done
   image_list=${lookup[@]}
   echo  3\>\&1 1\>\&2 2\>\&3\) >> $TMP_FILE

   source "$TMP_FILE"
   if test $? -ne 0; then return 99; fi

   # trim the string
   CHOICE=$(echo $CHOICE | awk '{print $1}')
   echo $1/$(get_nth $CHOICE $image_list )
}

selectFile(){
   # called by image2SD
   TMP_FILE=/tmp/duper/copy2sd

   cat << EOF > "$TMP_FILE"
   TITLE=$(gettext "SELECT FILE -- $OBJECTIVE")
   MSG=$(gettext "Choose hard disk image to Copy to SD card")
EOF
   image_path=$(selectImage $DEVICE_MOUNT/iiab $TMP_FILE )
   if test $? -ne 0; then return 99; fi
   SRC_DEVICE=$image_path
   SRC_FILE_SIZE=$(ptable_size $image_path)
   WILLITFIT_SRC_SIZE=$SRC_FILE_SIZE
   CHOSEN_SIZE=$SRC_FILE_SIZE
}

################   Top Level Action Routines   ####################
copySD(){
   selectSource
   if test $? -ne 0; then return 99; fi
   selectDestination
   if test $? -ne 0; then return 99; fi
   if [  "$dest_is_file" = "true" ]; then
      createFilename
   fi
   willItFit
   if test $? -ne 0; then return 99; fi
   finalVerification
   if test $? -ne 0; then return 99; fi
   ddCopy
}

makeSmaller(){
   TMP_FILE=/tmp/duper/smaller
   DEST_MNT=$(getPersistedVariable PREFERRED_MOUNT)
   PART=/dev/${DEST_MNT:5}
   # at boot, the read-only driver loads
   umount $DEST_MNT
   mount -t ntfs-3g "$PART" "$DEST_MNT"

   cat << EOF > "$TMP_FILE"
   TITLE=$(gettext "\"Choose Image to make Smaller -- $OBJECTIVE\"")
   MSG=$(gettext "\"Must have unused space to be of much use\"")
EOF
   image_path=$(selectImage  $DEST_MNT/iiab $TMP_FILE )

   # get the proposed new size
   new_size=$(min_device_size $image_path)
   human=$(bytesToHuman $new_size)
   current_size=$(ls -lh $image_path | awk '{print $5}')
   
   TITLE=$(gettext "OK to proceed? -- $OBJECTIVE")
   MSG=$(gettext "The image file $image_path is currently $current_size. \n
It's new size will be $human. Do you want to proceed?")
   
   dialog --title "$TITLE" --yesno "$MSG" 9 80
   if test $? -ne 0; then return 99; fi

   size_image $image_path
   return 0 
}

image2SD(){
   selectFile 
   if test $? -ne 0; then return 99; fi
   selectSDDestination
   if test $? -ne 0; then return 99; fi
   willItFit
   if test $? -ne 0; then return 99; fi
   finalVerification
   if test $? -ne 0; then return 99; fi
   ddCopy
}

deleteImage(){
   TMP_FILE=/tmp/duper/delete
   DEST_MNT=$(getPersistedVariable PREFERRED_MOUNT)
   PART=/dev/${DEST_MNT:5}
   # at boot, the read-only driver loads
   umount $DEST_MNT
   mount -t ntfs-3g "$PART" "$DEST_MNT"

   cat << EOF > $TMP_FILE
   TITLE=$(gettext "\"Choose a File to Delete -- $OBJECTIVE\"")
   MSG=$(gettext "\"Highlight the file you wish to delete\"")
EOF
   image_path=$(selectImage  $DEST_MNT/iiab $TMP_FILE )
   if test $? -ne 0; then return 99; fi

   TITLE=$(gettext "OK to proceed? -- $OBJECtIVE")
   MSG=$(gettext "The image file $image_path is about to be deleted. \
Do you want to proceed?")
   
   dialog --title "$TITLE" --yesno "$MSG" 6 80
   if test $? -ne 0; then return 99; fi


   echo $image_path | grep iiab  # protection for total hard disk wipeout
   if [ $? -eq 0 ]; then
      rm -f $image_path
   else
      echo "iiab not in full path of delete -- aborting"
      exit 1
   fi
   return 0 
}

#######################   Main Menu   ###############################
mainMenu(){
   choice1=$(gettext "Copy to SD Card or hard disk")
   choice2=$(gettext "Reduce the size of hard disk image")
   choice3=$(gettext "Copy from hard disk image to SD card")
   choice4=$(gettext "Delete hard disk image")
   choice5=$(gettext "Help")
   choice6=$(gettext "Exit to command line terminal")
   title=$(gettext "MAIN MENU")
   msg=$(gettext "\n\nPlease choose from the following options:")
   ACTION=$(dialog --title "$title"  --ok-button Select --cancel-button quit --menu "$msg" 17 80 7   \
   "copysd" "$choice1" \
   "smaller" "$choice2" \
   "image2sd" "$choice3" \
   "delete" "$choice4" \
   "help" "$choice5" \
   "terminal" "$choice6" \
   3>&1 1>&2 2>&3)
   if test $? -ne 0 ; then exit 1 ; fi
   case "$ACTION" in
      copysd) 
         OBJECTIVE=$choice1
         copySD
         ;;
      smaller) 
         OBJECTIVE=$choice2
         makeSmaller
         ;;
      image2sd) 
         OBJECTIVE=$choice3
         image2SD
         ;;
      delete)
         OBJECTIVE=$choice4
         deleteImage
         ;;
      terminal)
         clear
         resume_text=$(gettext "Thank you for using the IIAB duper, You can Copy more SD cards by \
         typing \"duper\".\n\n")
         echo -e $resume_text
         exit 1
         ;;
      help|*)
         usage
         ;;
   esac
}

cleanup(){
   if [ $? -eq 99 ]; then
      if [ ! -z "$error_msg" ]; then
         dialog --title "ERROR" --info $error_msg
         error_msg=
      fi
      trap cleanup EXIT INT TERM
      main
   fi
   umount /mnt/$SRC_DEVICEi &> /dev/null
   if [ "$dest_is_usb" = "true" ]; then
      umount "$DEST_DEVICE" &> /dev/null
   fi
}

main(){
   while true; do
      mainMenu
   done
}

trap cleanup EXIT INT TERM

initialize "$@"
checkSudo "$@"

main "$@"
